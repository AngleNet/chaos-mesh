
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.2.5
  creationTimestamp: null
  name: stresschaos.pingcap.com
spec:
  group: pingcap.com
  names:
    kind: StressChaos
    listKind: StressChaosList
    plural: stresschaos
    singular: stresschaos
  scope: Namespaced
  validation:
    openAPIV3Schema:
      description: StressChaos is the Schema for the stresschaos API
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          description: Spec defines the behavior of a time chaos experiment
          properties:
            duration:
              description: Duration represents the duration of the chaos action
              type: string
            mode:
              description: 'Mode defines the mode to run chaos action. Supported mode:
                one / all / fixed / fixed-percent / random-max-percent'
              type: string
            nextRecover:
              description: Next time when this action will be recovered
              format: date-time
              type: string
            nextStart:
              description: Next time when this action will be applied again
              format: date-time
              type: string
            scheduler:
              description: Scheduler defines some schedule rules to control the running
                time of the chaos experiment about time.
              properties:
                cron:
                  description: "Cron defines a cron job rule. \n Some rule examples:
                    \"0 30 * * * *\" means to \"Every hour on the half hour\" \"@hourly\"
                    \     means to \"Every hour\" \"@every 1h30m\" means to \"Every
                    hour thirty\" \n More rule info: https://godoc.org/github.com/robfig/cron"
                  type: string
              required:
              - cron
              type: object
            selector:
              description: Selector is used to select pods that are used to inject
                chaos action.
              properties:
                annotationSelectors:
                  additionalProperties:
                    type: string
                  description: Map of string keys and values that can be used to select
                    objects. A selector based on annotations.
                  type: object
                fieldSelectors:
                  additionalProperties:
                    type: string
                  description: Map of string keys and values that can be used to select
                    objects. A selector based on fields.
                  type: object
                labelSelectors:
                  additionalProperties:
                    type: string
                  description: Map of string keys and values that can be used to select
                    objects. A selector based on labels.
                  type: object
                namespaces:
                  description: Namespaces is a set of namespace to which objects belong.
                  items:
                    type: string
                  type: array
                nodeSelectors:
                  additionalProperties:
                    type: string
                  description: Map of string keys and values that can be used to select
                    nodes. Selector which must match a node's labels, and objects
                    must belong to these selected nodes.
                  type: object
                nodes:
                  description: Nodes is a set of node name and objects must belong
                    to these nodes.
                  items:
                    type: string
                  type: array
                podPhaseSelectors:
                  description: 'PodPhaseSelectors is a set of condition of a pod at
                    the current time. supported value: Pending / Running / Succeeded
                    / Failed / Unknown'
                  items:
                    type: string
                  type: array
                pods:
                  additionalProperties:
                    items:
                      type: string
                    type: array
                  description: Pods is a map of string keys and a set values that
                    used to select pods. The key defines the namespace which pods
                    belong, and the each values is a set of pod names.
                  type: object
              type: object
            stressors:
              description: Stressors defines plenty of stressors supported to stress
                system components out. You can use one or more of them to make up
                various kinds of stresses. At least one of the stressors should be
                specified.
              properties:
                cpu:
                  description: CPUStressor stresses CPU out
                  properties:
                    load:
                      default: 100
                      description: Load specifies P percent loading per CPU worker.
                        0 is effectively a sleep (no load) and 100 is full loading.
                      type: integer
                    method:
                      default: all
                      description: "Method specify a cpu stress method. By default,
                        all the stress methods are exercised sequentially, however
                        one can specify just one method to be used if required. Available
                        cpu stress methods are described as follows: Method \t\t\tDescription
                        all\t\t\t\titerate over all the below cpu stress methods ackermann
                        \   \tAckermann function: compute A(3, 10), where:              \t
                        \ A(m, n) = n + 1 if m = 0;              \t  A(m - 1, 1) if
                        m > 0 and n = 0;              \t  A(m - 1, A(m, n - 1)) if
                        m > 0 and n > 0 bitops       \tvarious bit operations from
                        bithack, namely: reverse bits, parity check, bit count, round
                        to nearest power of 2 callfunc     \trecursively call 8 argument
                        C function to a depth of 1024 calls and unwind cfloat       \t1000
                        iterations of a mix of floating point complex operations cdouble
                        \     \t1000 iterations of a mix of double floating point
                        complex operations clongdouble  \t1000 iterations of a mix
                        of long double floating point complex operations correlate
                        \   \tperform a 16384 × 1024 correlation of random doubles
                        crc16        \tcompute 1024 rounds of CCITT CRC16 on random
                        data decimal32    \t1000 iterations of a mix of 32 bit decimal
                        floating point operations (GCC only) \n decimal64    \t1000
                        iterations of a mix of 64 bit decimal floating point operations
                        (GCC only) decimal128   \t1000 iterations of a mix of 128
                        bit decimal floating point operations (GCC only) dither       \tFloyd–Steinberg
                        dithering of a 1024 × 768 random image from 8 bits down to
                        1 bit of depth. djb2a        \t128 rounds of hash DJB2a (Dan
                        Bernstein hash using the xor variant) on 128 to 1 bytes of
                        random strings double       \t1000 iterations of a mix of
                        double precision floating point operations euler        \tcompute
                        e using n = (1 + (1 ÷ n)) ↑ n explog       \titerate on n
                        = exp(log(n) ÷ 1.00002) factorial    \tfind factorials from
                        1..150 using Stirling's and Ramanujan's approximations fibonacci
                        \   \tcompute Fibonacci sequence of 0, 1, 1, 2, 5, 8... fft
                        \         \t4096 sample Fast Fourier Transform float        \t1000
                        iterations of a mix of floating point operations float16      \t1000
                        iterations of a mix of 16 bit floating point operations float32
                        \     \t1000 iterations of a mix of 32 bit floating point
                        operations float80      \t1000 iterations of a mix of 80 bit
                        floating point operations float128     \t1000 iterations of
                        a mix of 128 bit floating point operations fnv1a        \t128
                        rounds of hash FNV-1a (Fowler–Noll–Vo hash using the xor then
                        multiply variant) on 128 to 1 bytes of random strings gamma
                        \       \tcalculate  the Euler-Mascheroni constant γ using
                        the limiting difference between the harmonic series (1 + 1/2
                        + 1/3 + 1/4 + 1/5 ... + 1/n) and the natural              \tlogarithm
                        ln(n), for n = 80000. gcd              compute GCD of integers
                        gray             calculate binary to gray code and gray code
                        back to binary for integers from 0 to 65535 hamming          compute
                        Hamming H(8,4) codes on 262144 lots of 4 bit data. This turns
                        4 bit data into 8 bit Hamming code containing 4 parity bits.
                        For data  bits  d1..d4,                  parity bits are computed
                        as:                    p1 = d2 + d3 + d4                    p2
                        = d1 + d3 + d4                    p3 = d1 + d2 + d4                    p4
                        = d1 + d2 + d3 hanoi            solve a 21 disc Towers of
                        Hanoi stack using the recursive solution hyperbolic       compute
                        sinh(θ) × cosh(θ) + sinh(2θ) + cosh(3θ) for float, double
                        and long double hyperbolic sine and cosine functions where
                        θ = 0 to 2π in 1500 steps idct             8 × 8 IDCT (Inverse
                        Discrete Cosine Transform) int8             1000 iterations
                        of a mix of 8 bit integer operations int16            1000
                        iterations of a mix of 16 bit integer operations int32            1000
                        iterations of a mix of 32 bit integer operations int64            1000
                        iterations of a mix of 64 bit integer operations int128           1000
                        iterations of a mix of 128 bit integer operations (GCC only)
                        int32float       1000 iterations of a mix of 32 bit integer
                        and floating point operations int32double      1000 iterations
                        of a mix of 32 bit integer and double precision floating point
                        operations int32longdouble  1000 iterations of a mix of 32
                        bit integer and long double precision floating point operations
                        int64float       1000 iterations of a mix of 64 bit integer
                        and floating point operations int64double      1000 iterations
                        of a mix of 64 bit integer and double precision floating point
                        operations int64longdouble  1000 iterations of a mix of 64
                        bit integer and long double precision floating point operations
                        int128float      1000 iterations of a mix of 128 bit integer
                        and floating point operations (GCC only) int128double     1000
                        iterations of a mix of 128 bit integer and double precision
                        floating point operations (GCC only) int128longdouble 1000
                        iterations of a mix of 128 bit integer and long double precision
                        floating point operations (GCC only) int128decimal32  1000
                        iterations of a mix of 128 bit integer and 32 bit decimal
                        floating point operations (GCC only) int128decimal64  1000
                        iterations of a mix of 128 bit integer and 64 bit decimal
                        floating point operations (GCC only) int128decimal128 1000
                        iterations of a mix of 128 bit integer and 128 bit decimal
                        floating point operations (GCC only) jenkin           Jenkin's
                        integer hash on 128 rounds of 128..1 bytes of random data
                        jmp              Simple unoptimised compare >, <, == and jmp
                        branching ln2              compute ln(2) based on series:
                        \                   1 - 1/2 + 1/3 - 1/4 + 1/5 - 1/6 ... longdouble
                        \      1000 iterations of a mix of long double precision floating
                        point operations loop             simple empty loop matrixprod
                        \      matrix  product  of  two  128  × 128 matrices of double
                        floats. Testing on 64 bit x86 hardware shows that this is
                        provides a good mix of memory, cache and                  floating
                        point operations and is probably the best CPU method to use
                        to make a CPU run hot. nsqrt            compute sqrt() of
                        long doubles using Newton-Raphson omega            compute
                        the omega constant defined by Ωe↑Ω = 1 using efficient iteration
                        of Ωn+1 = (1 + Ωn) / (1 + e↑Ωn) parity           compute parity
                        using various methods from the Standford Bit Twiddling Hacks.
                        \ Methods employed are: the naïve way, the naïve way with
                        the  Brian  Kernigan                  bit counting optimisation,
                        the multiply way, the parallel way, and the lookup table ways
                        (2 variations). phi              compute the Golden Ratio
                        ϕ using series pi               compute π using the Srinivasa
                        Ramanujan fast convergence algorithm pjw              128
                        rounds of hash pjw function on 128 to 1 bytes of random strings
                        prime            find all the primes in the range  1..1000000
                        using a slightly optimised brute force naïve trial division
                        search psi              compute ψ (the reciprocal Fibonacci
                        constant) using the sum of the reciprocals of the Fibonacci
                        numbers queens           compute all the solutions of the
                        classic 8 queens problem for board sizes 1..12 \n rand             16384
                        \ iterations  of  rand(),  where rand is the MWC pseudo random
                        number generator.  The MWC random function concatenates two
                        16 bit multiply-with-carry                  generators:                   x(n)
                        = 36969 × x(n - 1) + carry,                   y(n) = 18000
                        × y(n - 1) + carry mod 2 ↑ 16 \n                  and has
                        period of around 2 ↑ 60 rand48           16384 iterations
                        of drand48(3) and lrand48(3) rgb              convert RGB
                        to YUV and back to RGB (CCIR 601) sdbm             128 rounds
                        of hash sdbm (as used in the SDBM database and GNU awk) on
                        128 to 1 bytes of random strings sieve            find the
                        primes in the range 1..10000000 using the sieve of Eratosthenes
                        stats            calculate minimum, maximum, arithmetic mean,
                        geometric mean, harmoninc mean and standard deviation on 250
                        randomly  generated  positive  double  precision                  value.
                        sqrt             compute sqrt(rand()), where rand is the MWC
                        pseudo random number generator trig             compute sin(θ)
                        × cos(θ) + sin(2θ) + cos(3θ) for float, double and long double
                        sine and cosine functions where θ = 0 to 2π in 1500 steps
                        union            perform  integer  arithmetic  on  a  mix
                        of bit fields in a C union.  This exercises how well the compiler
                        and CPU can perform integer bit field loads and                  stores.
                        zeta             compute the Riemann Zeta function ζ(s) for
                        s = 2.0..10.0"
                      type: string
                    workers:
                      description: Workers specifies N workers to apply the stressor.
                      type: integer
                  required:
                  - workers
                  type: object
                vm:
                  description: VmStressor stresses virtual memory out
                  properties:
                    bytes:
                      default: 100%
                      description: Bytes specifies N bytes consumed per vm worker,
                        default is the total available memory. One can specify the
                        size as % of total available memory or in units of B, KB/KiB,
                        MB/MiB, GB/GiB, TB/TiB.
                      type: string
                    workers:
                      description: Workers specifies N workers to apply the stressor.
                      type: integer
                  required:
                  - workers
                  type: object
              type: object
            value:
              description: Value is required when the mode is set to `FixedPodMode`
                / `FixedPercentPodMod` / `RandomMaxPercentPodMod`. If `FixedPodMode`,
                provide an integer of pods to do chaos action. If `FixedPercentPodMod`,
                provide a number from 0-100 to specify the max % of pods the server
                can do chaos action. If `RandomMaxPercentPodMod`,  provide a number
                from 0-100 to specify the % of pods to do chaos action
              type: string
          required:
          - mode
          - selector
          - stressors
          type: object
        status:
          description: Most recently observed status of the time chaos experiment
          properties:
            experiment:
              description: Experiment records the last experiment state.
              properties:
                endTime:
                  format: date-time
                  type: string
                phase:
                  description: ExperimentPhase is the current status of chaos experiment.
                  type: string
                podChaos:
                  items:
                    description: PodStatus represents information about the status
                      of a pod in chaos experiment.
                    properties:
                      action:
                        type: string
                      hostIP:
                        type: string
                      message:
                        description: A brief CamelCase message indicating details
                          about the chaos action. e.g. "delete this pod" or "pause
                          this pod duration 5m"
                        type: string
                      name:
                        type: string
                      namespace:
                        type: string
                      podIP:
                        type: string
                    required:
                    - action
                    - hostIP
                    - name
                    - namespace
                    - podIP
                    type: object
                  type: array
                reason:
                  type: string
                startTime:
                  format: date-time
                  type: string
              type: object
            instance:
              description: Instance always specifies a stressing instance
              type: string
            phase:
              description: Phase is the chaos status.
              type: string
            reason:
              type: string
          required:
          - experiment
          - instance
          - phase
          type: object
      required:
      - spec
      type: object
  version: v1alpha1
  versions:
  - name: v1alpha1
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
